## 计算机系统基础知识

### 计算机系统的基本组成

计算机系统由硬件系统和软件系统组成。

#### 计算机硬件

基本的计算机硬件系统由运算器、控制器、存储器、输入设备和输出设备五大部件组成。通信部件也称为计算机系统的基本组件。

运算器和控制器被集成在一起，统称为中央处理单元（Central Processing Unit，CPU）。CPU 是硬件系统的核心，用于数据的加工处理，完成各种算数、逻辑运算及控制功能。

运算器主要完成算数和逻辑运算。

控制器主要从主存中取出指令并进行分析，控制计算机的各个部件有条不紊地完成指令。

存储器是计算机系统中的记忆设备，分为内部存储器（Main Memory，MM，简称内存、主存）和外部存储器（简称外存、辅存）。相对来说，内存速度快、容量小，一般用来临时存储计算机运行时所需的程序、数据及运算结果。外存容量大、速度慢，可用于长期保存信息。

寄存器是 CPU 中的存储器件，用来临时存放少量的数据、运算结果和正在执行的指令。与内存储器相比，寄存器的速度要快得多。

习惯上将 CPU 和主存储器的有机组合称为主机。输入/输出（I/O）设备位于主机之外，是计算机系统与外界交换信息的装置。输入设备将信息输入计算机的存储器，输出设备把预算结果按照人们所要求的形式输出到外部设备或存储介质上。

#### 计算机软件

计算机软件是指为管理、运行、维护及应用计算机系统所开发的程序和相关文档的集合。主要用来将解决问题的步骤编织成机器可识别的程序并加载到计算机内存开始运行。

通常将软件分为系统软件、中间件和应用软件。

系统软件的主要功能是管理系统的硬件和软件资源。

中间件是一类独立的系统软件或服务程序，常用来管理计算资源和网络通信，提供通信处理、数据存取、事务处理、Web 服务、安全、跨平台等服务。

应用软件用于解决应用领域的具体问题。

#### 计算机分类

1. 个人移动设备（Personal Mobile Device，PMD）。一类带有多媒体用户界面的无线设备，如智能手机、平板电脑等。
2. 桌面计算机。如台式计算机、笔记本计算机、工作站等。台式计算机、笔记本计算机、工作站都是微型计算机。工作站其实和台式计算机差不多，主要是配置高，一般用来给工程设计、动画制作、科学研究等专业领域服务的。
3. 服务器。主要提供大规模和可靠的文件及计算服务，强调可用性、可扩展性和很高的吞吐率。
4. 集群/仓库级计算机。集群机是将一组桌面计算机或服务器用网络连接在一起（就像学校机房），仓库级计算机是将数万个服务器连接在一起形成的大规模集群。
5. 超级计算机。规格高，性能强大，具有很强的计算能力，但耗能巨大。我国的超级计算机主要有银河、天河、曙光、神威四个系列。例如，神威·太湖之光由 40 个运算机柜和 8 个网络机柜组成，共有 40960 块处理器，每一块处理器相当于 20 多台常用笔记本计算机的计算能力。
6. 嵌入式计算机。是专用的，针对某个特定的应用，如针对网络、通信、音频、视频或针对工业控制，对功能、可靠性、成本、体积、功耗由严格要求的计算机系统。如微波炉、洗衣机、数码产品、网络交换机等都采用嵌入式计算机技术。

### 数据的表示及运算

#### 计算机中数据的表示

编码：采用少量的基本符号，选用一定的组合原则来表示大量复杂多样的信息。编码的两大要素：基本符号的种类、符号的组合规则。

##### 进位计数制及其转换

在采用进位计数的数字系统中，如果只用 r 个基本符号表示数值，则称为 r 进制（Radix-r Number System），r 称为该数制的基数（Radix）。

不同数制共同特点：

1. 都有固定的符号集。如，二进制的基本符号只有两个 0 和 1.
2. 都使用位置表示法。如，$7.5=1*2^2+1*2^1+1*2^0+1*2^{-1}$

常用计数制：

| 进位制     | 二进制   | 八进制    | 十进制    | 十六进制          |
| ---------- | -------- | --------- | --------- | ----------------- |
| 规则       | 逢二进一 | 逢八进一  | 逢十进一  | 逢十六进一        |
| 基数       | r=2      | r=8       | r=10      | r=16              |
| 数符       | 0,1      | 0,1,2,…,7 | 0,1,2,…,9 | 0,1,2,…,9,A,B,…,F |
| 权         | $2^i$    | $8^i$     | $10^i$    | $16^i$            |
| 形式表示符 | B        | O         | D         | H                 |

十进制转二进制：

![](图片\十进制转二进制.png)

二进制转十进制：

![](图片\二进制转十进制.png)

八进制转十进制：

![八进制转二进制](图片\八进制转十进制.png)

二进制转八进制：

![](图片\二进制转八进制.png)

十六进制转换方法同八进制，二进制转十六进制时是 4 位二进制一看。

##### 二进制运算规则

1. 加法：逢二进一

   0 + 0 = 0

   1 + 0 = 1

   0 + 1 = 1

   1 + 1 = 0（有进位）

2. 减法：借一当二

   0 - 0 = 0

   1 - 0 = 1

   0 - 1 = 1（有借位）

   1 - 1 = 0

3. 乘法

   0 * 0 = 0

   1 * 0 = 0

   0 * 1 = 0

   1 * 1 = 1

##### 机器数和码制

各种数据在计算机中表示的形式称为机器数，采用二进制计数制，小数点隐含表示而不占位置。机器数对应的实际数值称为数的真值。

对于带符号数，机器数的最高位表示正、负的符号位，其余位则表示数值。若约定小数点的位置在机器数的最低数值位之后，则是纯整数；若约定小数点的位置在机器数的最好数值位之前（符号位之后），则是纯小数。无符号数是指全部二进制位均代表数值，没有符号位。

为了便于运算，<font color=skyblue>带符号</font>的机器数可采用原码、反码和补码、移码等不同的<font color=skyblue>编码方法</font>。

###### 原码

数值 X 的原码标记为 $[X]_原$，如果机器字长为 n（即采用 n 个二进制位表示数据），则最高位是符号位，0 表示表示正号，1 表示负号，其余的 n - 1 位表示数值的绝对值。数值 0 的原码表示有两种形式：

1. $[+0]_原=00000000$
2. $[-0]_原=10000000$

例题：

![](图片\原码例题 1.png)

###### 反码

数值 X 的反码记作 $[X]_反$，如果机器字长为 n，则最高位是符号位，0 表示正好，1 表示负号，其余的 n - 1 位表示数值。整数的反码与原码相同，负数的反码则是其绝对值按位求反。数值 0 的反码表示有两种形式：

1. $[+0]_反=00000000$
2. $[-0]_反=11111111$

例题：

![](图片\反码例题 1.png)

###### 补码

数值 X 的补码记作 $[X]_补$，如果机器字长为 n，则最高位为符号位，0 表示正号，1 表示负号，其余的 n - 1 位表示数值。正数的补码与其原码和反码相同，负数的补码则等于其反码的末尾加 1。<font color=skyblue>n 位补码表示法有一个例外，当符号位为 1 而数值位全部为 0 时，它表示整数 $2^{n-1}$，即此时符号位的 1 既表示负数又表示数值。</font>设计补码时，引用了模运算在数理上对符号位的处理，利用模的自动丢弃实现了符号位的自然处理，例如，$1+(-1)$ 使用补码可以直接计算出等于 0，而原码和反码得到的结果时错误的。用补码表示数时，由于符号位和数值部分一起编码，很难从码值形式直接判断真值的大小。例如，45 > -45，而其补码 00101101 在形式上小于 11010011。

在补码表示中，0 有唯一的编码：

$[+0]_补=00000000$，$[-0]_补=00000000$

例题：

![](图片\补码例题 1.png)

###### 移码

移码表示法是在数 X 上增加一个偏移量来定义的，常用于表示浮点数中的阶码。<font color=skyblue>如果机器字长为 n，在偏移量为 $2^{n-1}$ 时，只要将补码的符号位取反便可获得相应的移码表示。</font>偏移量也可以时其他值。采用移码表示时，码值大者对应的真值就大。

例题：

![](图片\移码例题 1.png)

##### 定点数和浮点数

定点数就是表示数据时小时点位置固定不变，小数点的位置通常有两种约定方式：顶点整数（纯整数，小数点在最低有效数值位之后）和定点小数（纯小数，小数点在最高有效数值位之前）。

设机器字长为 n，定点数的补码和移码可表示 $2^n $个数，原码和反码只能表示 $2^n-1$ 个数，因为 0 表示占用了两个编码。各种码制表示下的带符号数的范围：

| 码制 | 定点整数                       | 定点小数                             |
| ---- | ------------------------------ | ------------------------------------ |
| 原码 | $-(2^{n-1}-1)\sim+(2^{n-1}-1)$ | $-(1-2^{-(n-1)})\sim+(1-2^{-(n-1)})$ |
| 反码 | $-(2^{n-1}-1)\sim+(2^{n-1}-1)$ | $-(1-2^{-(n-1)})\sim+(1-2^{-(n-1)})$ |
| 补码 | $-2^{n-1}\sim(2^{n-1}-1)$      | $-1\sim+(1-2^{-(n-1)})$              |
| 移码 | $-2^{n-1}\sim(2^{n-1}-1)$      | $-1\sim+(1-2^{-(n-1)})$              |

浮点数是小数点位置不固定的数，浮点表示法能表示更大范围的数。一个含小数点的二级制数 N 可以表示为更一般的形式：$N=2^E\times F$，其中 E 为阶码，F 为尾数，这种表示数的方法称为浮点表示法。浮点表示法中，阶码通常为带符号的纯整数，尾数为带符号的纯小数。浮点数表示的格式：

![](图片\浮点表示的格式.png)

<font color=skyblue>一个数的浮点表示不是唯一的。</font>当小数点的位置改变时，阶码也相应改变，因此可以用多种浮点形式表示同一个数。

浮点数所能表示的数值范围主要由阶码决定，所表示数值的精确度由尾数决定。

浮点数的规格化表示：当尾数的值不为 0 时，规定尾数域的最高有效位应为 1，否则修改阶码同时左移或右移小数点的位置，使其变为规格化数的形式。简单来说，规格化就是将尾数的绝对值限定在区间 [0.5,1)。

1. 若尾数 $F \geq 0$，则其规格化尾数形式为 $F=01XXX\cdots X$，其中 X 可为 0，也可为 1，即尾数的范围限定在区间 [0.5,1)。
2. 若尾数 $F < 0$，则其规格化尾数形式为 $F=10XXX\cdots X$，其中 X 可为 0，也可为 1，即尾数的范围限定在区间(-1,-0.5]。

IEEE754 是由 IEEE 制定的有关浮点数的工业标准。该标准表示形式：

![](图片\IEEE754 表示形式.png)

其中，S 为数的符号位，为 0 时表示正数，为 1 时表示负数；P 为指数（阶码），用移码表示（偏移值为 $2^{p-1}-1$，p 为阶码的位数）；M 为尾数，用原码表示。

对于阶码为 0 或 255 的情况，IEEE754 标准有特别的规定：若 P 为 0 且 M 为 0，则表示真值 $\pm0$（正负号和数符位有关）。如果 P=255 并且 M 是 0，则，这个数的真值为 $\pm\infty$（与符号位有关）；如果 P=255 并且 M 不是 0，则这不是一个数（NaN）。

目前，计算机中主要使用 3 中形式的 IEEE754 浮点数：

| 参数             | 单精度浮点数          | 双精度浮点数            | 扩充精度浮点数            |
| ---------------- | --------------------- | ----------------------- | ------------------------- |
| 浮点数字长       | 32                    | 64                      | 80                        |
| 尾数长度         | 23                    | 52                      | 64                        |
| 符号位长度       | 1                     | 1                       | 1                         |
| 阶码长度         | 8                     | 11                      | 15                        |
| 指数偏移量       | +127                  | +1023                   | +16383                    |
| 可表示的实数范围 | $10^{-38}\sim10^{38}$ | $10^{-308}\sim10^{308}$ | $10^{-4932}\sim10^{4932}$ |

在 IEEE754 标准中，对于单精度浮点数和双精度浮点数，约定小数点左边隐含有一位，通常这位数就是 1，因此尾数为 $1.XXX\cdots X$。

例题：

![](图片\IEEE754 标准例题 1.png)

![](图片\IEEE754 标准例题 2.png)

##### 十进制数与字符的编码表示

数值、文字和英文字母等都被认为是字符。任何字符被录入计算机后，都必须转换成二进制表示形式，称为字符编码。

用 4 位二进制代码表示一位十进制数，称为二-十进制编码，简称 BCD 编码。因为 $2^4=16$，而十进制数只有 0~9 这 10 个不同的数符，故有多种 BCD 编码。根据 4 位代码中每一位是否有确定的权来划分，可分为有权码和无权码两类。有权码应用最多的是 8421 码。无权码常用的有余 3 码和格雷码。

8421 码，即 4 个二进制位的权从高到低分别位 8、4、2、1。

余 3 码，在 8421 码的基础上加 0011 后构成的。

格雷码的编码规则是相邻的两个代码之间只有一位不同。格雷码不是唯一的。

| 十进制数 | 8421 码 | 余 3 码 | 格雷码 |
| -------- | ------- | ------- | ------ |
| 0        | 0000    | 0011    | 0000   |
| 1        | 0001    | 0100    | 0001   |
| 2        | 0010    | 0101    | 0011   |
| 3        | 0011    | 0110    | 0010   |
| 4        | 0100    | 0111    | 0110   |
| 5        | 0101    | 1000    | 1110   |
| 6        | 0110    | 1001    | 1010   |
| 7        | 0111    | 1010    | 1000   |
| 8        | 1000    | 1011    | 1100   |
| 9        | 1001    | 1100    | 0100   |

##### ASCII码

ASCII 码（American Standard Code for Information Interchange，美国标准信息交换代码）被国际标准化组织 ISO 采纳。基本 ASCII 码采用 7 位二进制，对字符进行编码：低 4 位组用作行编码，高 3 位组用作列编码。

![](图片\ASCII 码表.png)

0 在表格的第 1 行第 4 列，所以 0 的 ASCII 码为 011 0000（48）；A 在表格的第 2 行第 5 列，所以 A 的 ASCII 码为 100 0001（65）；a 在表格的第 7 列第 2 行，所以 a 的 ASCII 码为 110 0001（97）。

##### 汉字编码

计算机处理汉字，必须先将汉字代码化，即对汉字进行编码。汉字处理包括汉字的编码输入、汉字的存储和汉字的输出等环节。

###### 输入码

汉字的输入码分为三类：数字编码、拼音码、字形码。

<font color=skyblue>数字编码</font>就是用数字串代表一个汉字的输入，常用国标区位码。国标区位码将国家标准局公布的 6763 个两级汉字分成 94 个区，每个区 94 位，区码和位码各两位十进制数。汉字区位码表是有规律的。在 94 个分区中，1~15 区用来表示字母、数字、符号。16~87 区为一级和二级汉字。一级汉字以汉语拼音为序排列，二级汉字以偏旁部首进行排列。使用区位码方法输入汉字时必须先在表中查找汉字对应代码，才能输入。数字编码输入的优点是无重码，而且输入码和内部编码内部转换比较方便，但是数字码难以记忆。

<font color=skyblue>拼音码</font>是以汉语读音为基础的输入方法。缺点：汉字同音字太多，输入重码率高，影响输入速度。

<font color=skyblue>字形编码</font>以汉字形状确定的编码。全部汉字的部件和笔画有限，所以把汉字的笔画用字母或数字进行编码，按笔画书写的顺序依次输入，就能表示一个汉字。五笔字型、表形码便是这种编码。五笔字型编码是最常见的输入码。

###### 内部码

汉字内部码简称汉字内码，是汉字在设备和信息处理系统内部存储、处理、传输汉字用的代码。由于汉字数量多，用一个字节无法区分，采用国家标准局 GB2312-1980 中规定的汉字国标码。两个字节存放一个汉字的内码，每个字节的最高位置 1，作为汉字机内码。由于两个字节各用 7 位，因此可表示 $2^{14}=16384$ 个可区别的机内码。例如，汉字 “大”，国标码为 3473H（H 代表十六进制，也就是国标码为十六进制编码下的 3473），两个字节最高位置 1 后获得机内码 B4F3H。即：

国标码：$(3473)_H$ -> $(0011 0100 0111 0011)_B$

机内码：国标码的两个字节的最高位分别置 1（每个字节 8 位）：$(1011 0100 1111 0011)_B$ -> $(B4F3)_H$

最快的计算方法是将十六进制下的国标码从左往右数第 1 位和第 3 位 +8 即可，$3+8=11(B)$，$7+8=15(F)$。

GB18030-2005《信息技术中文编码字符集》是我国最新的内码字符集，与 GB2312-1980 完全兼容，支持 GB13000 即 Unicode 的全部统一汉字，共收录汉字 70244 个。

###### 字形码

汉字字形码是表示汉字字形的字模数据，通常用点阵、矢量函数等方式表示。用点阵表示字形时，汉字字形码指的就是汉字字形点阵的代码。字形码也称字模码，是用点阵表示，是汉字的输出方式。根据输出汉字的要求不同，点阵的多少也不同。简易性汉字为 $16\times 16$，高精度性汉字为 $24\times 24$点阵、$32\times 32$点阵、$48\times 48$点阵等。

字模点阵所占用的存储空间很大，以 $16 \times 16$ 点阵为例，每个汉字需要 32 字节用于机内存储。可以这样想，一行有 16 位，一共有这样的 16 行；一行 16 位等于 2 个字节，那么有 16 行的 2 个字节；那么 $2\times 16=32$ 个字节。字库中存储了每个汉字的点阵代码，当显示输出时才检索字库，输出字模点阵得到字形。

汉字矢量表示法是将汉字看作由笔画组成的图形，提取每个笔画的坐标值，这些坐标值可以决定每一笔画的位置，将每一个汉字所有坐标值信息组合起来就是该汉字字型的矢量信息。汉字字形、笔画都影响其矢量信息。每个汉字矢量信息所占用的内存大小也不一样。将每个汉字的矢量信息集中在一起构成了汉字库。当需要汉字输出时，利用汉字字形检索程序根据汉字内码从字模库中找到相应的字形码。

##### Unicode

国际标准化组织 1993 年公布了 “通用多八位编码字符集” 国际标准 ISO/IEC 10646，简称 UCS（Universal Coded Character Set）。另一个是 Unicode（统一码、万国码、单一码）是软件制造商的协会（unicode.org）开发的可以容纳世界上所有文字和符号的字符编码标准，包括字符集、编码方案等。Unicode 2.0 开始采用与 ISO 10646-1 相同的字库和字码。目前这两个项目独立地公布各自的标准。

UCS 规定了两种编码格式：UCS-2 和 UCS-4。UCS-2 用两个字节编码，UCS-4 用 4 个字节（实际只用了 31 位，最高位必须为 0）编码。

Unicode 可以通过不同的编码实现，Unicode 标准定义了用于传输和保存的 UTF-8、UTF-16 和 UTF-32 等。其中 UTF 表示 UCS Transformation Format。在网络上广泛使用的 UTF-8 以 8 位（一个字节）为单元对 UCS 进行编码。从 UCS-2 到 UTF-8 的编码对应关系：

![](图片\UCS-2 到 UTF-8 的编码对应关系.png)

例如：“汉“ 的 UCS 编码为 $(6C49)_H = (0110 1100 0100 1001)_B$，位于 0800-FFFF 之间，所以采用 3 个字节模板，其 UTF-8 编码为 $(1110 0110 1011 0001 1000 1001)_B$，也就是 $(E6B189)_B$。

我国相应的国家标准为 GB 13000，等同于国际标准《通用多八位编码字符集（UCS）》ISO10646.1。

#### 校验码

在各部件之间进行数据交换采用校验码来检测传送的数据是否出错。这能提高硬件电路的可靠性，提高代码的校验能力，包括差错和纠错。

对数据可能出现的编码分为两类：<font color=skyblue>合法编码和错误编码</font>。合法编码用于传送数据，错误编码是不允许在数据中出现的编码。合理地设计错误编码以及编码规则，使得数据在传送中出现某种错误时就会变成错误编码，这样就可以检测接收到的数据是否有错。

码距，是指一个编码系统中任意两个合法编码之间至少有多少个二进制位不同。例如，4 为 8421 码的码距为 1，在传输过程中，该代码的一位或多为发生错误，都将编程另外 1 个合法编码，所以这种代码无差错检验能力。

3 种常用校验码：奇偶校验码（Parity Codes）、海明码（Hamming Codes）和 循环冗余校验码（Cyclic Redundancy Check,CRC）码。

##### 奇偶校验码

奇偶校验通过在编码中增加一个校验位来使编码中的 1 个数为奇数（奇校验）或者偶数（偶校验），从而使码距变为 2。对于奇偶校验，它可以发现检测代码中奇数位出错的编码，但不能发现偶数位出错的情况。

看下表很好理解，带奇校验位的 8421 码的校验码按 8421 码中 1 的个数来确定校验位，1 的个数为偶数则校验位为 1，1 的个数为奇数则校验位为 0。如果 8421 码中有 1 位出现了错误，那么校验位就会出现变化，也就知道 8421 码传输错误了。但如果 8421 码中有 2 位出现了错误，那么校验位不会出现变化，也就无法知道 8421 传输错误了。所以，奇偶校验只能检测出奇数个位出现的错误。

![](图片\8421 码的奇偶校验码.png)

常用的奇偶校验码有 3 种：水平奇偶校验码、垂直奇偶校验码和水平垂直校验码。

水平奇偶校验码：对每一个数据的编码添加校验位，使信息位与校验位处于同一行。

垂直奇偶校验码：把数据分成若干组，一组数据占一行，排列整齐，再加一行校验码，针对每一列采用奇校验或偶校验。

![](图片\垂直奇偶校验码例题 1.png)

水平垂直校验码：在垂直校验码的基础上，对每个数据再增加一位水平校验位。

![](图片\水平垂直校验码例题 1.png)

##### 海明码

海明码在数据位之间插入 k 个校验位，同过扩大码距来实现检错和纠错。校验位设置在 $2^i$ 上，每个校验位只校验数据位中位置号的二进制编码和自身位置号的二进制编码相匹配的数据位。

例题 1：

![](图片\海明码例题 1-1.png)

![](D:\Git 仓库\笔记\全国计算机技术与软件专业技术资格（水平）考试\计算机软件\程序员\图片\海明码例题 1-2.png)

![](图片\海明码例题 1-3.png)

例题 2：

![](图片\海明码例题 2.png)

<font color = skyblue>$\oplus$ 是异或符号，$A\oplus B$ 当 A 与 B 都为 1 或 1 时返回 0，当 A 与 B 不同时返回 1。</font>

<font color=skyblue>海明码能发现两位错误并纠正一位错误。</font>

##### 循环冗余校验码

循环冗余校验码广泛用于数据通信领域和磁介质存储系统中。它利用生成多项式 k 个数据位产生 r 个校验位来进行编码，其编码长度位 k + r。CRC 的代码格式：

![](图片\CRC 代码格式.png)

循环冗余校验码由两部分组成，左边信息码（数据），右边为校验码。若信息码占 k 位，则校验码占 n - k 位。其中 n 为 CRC 码的字长，所以又称（n，k）码。校验码是由信息码产生的，校验码位数越长，代码的校验能力就越强。在求 CRC 编码时，采用的是模 2 运算。

模 2 加减运算规则：按位运算，不发生错位和进位。

0 + 0 = 0	1 + 0 = 1	0 + 1 = 1	1 + 1 = 0

0 - 0 = 0	1 - 0 = 1	0 - 1 = 1	1 - 1 = 0

#### 逻辑代数及逻辑运算

逻辑代数是用代数的方式对逻辑变量进行描述和分析的数学工具，也称布尔代数。逻辑变量的取值只有 “真” 和 “假”。通常用 1 表示 “真”，0 表示 “假”。

##### 基本的逻辑运算

逻辑代数有 3 种基本运算：“与” 运算、“或” 运算和 “非” 运算。

“与” 运算：常用 AND、$\cap$、$\wedge$、$\cdot$ 表示。

“或” 运算：常用 OR、$\cup$、$\vee$、$+$ 表示。

“非” 运算：也称逻辑求反运算，常用 $\overline{A}$ 表示对变量 A 的值求反。

常用逻辑运算还有 “异或” 运算，又称半加运算，常用 XOR 或 $\oplus$ 表示。设 A 和 B 为两个逻辑变量，当且仅当 A、B 的值不同时，$A\oplus B$ 为真。$A\oplus B$ 的运算可由前 3 种基本运算表示：$A\oplus B=\overline{A}\cdot B + A\cdot \overline{B}$。

##### 常用逻辑公式

![](图片\逻辑代数常用逻辑公式.png)

##### 逻辑表达式及其化简

例题 1：

用真值表证明 $AB + A\overline{B} = A$

![](图片\逻辑表达式例题 1.png)

例题 2：

![](图片\逻辑表达式化简例题 1.png)

##### 机器数的运算

###### 机器数的加减运算

**原码加减法**

当两个相同符号的原码相加时，只需将数值部分直接相加，运算结果的符号与两个加数的符号相同。若两个加数的符号相异，则应进行减法运算。先比较两个数绝对值的大小，然后用绝对值大者的绝对值减去绝对值小者的绝对值，结果的符号取绝对值大者的符号。

例题：

X = 1010，Y = 11

```
	1010
-	0011
---------
	0111
也就是 100 时向 1 借 1 后，最后一位 0 变为了 2 - 1，第 2 位的 0 也变成了 1。
实在不会，用十进制试 100 - 2，就出来了
```

**补码加减法**

补码加法运算法则：$[X+Y]_补=[X]_补+[Y]_补$。

补码减法运算法则：差的补码等于被减数的补码加上减数取负后的补码。$[X-Y]_补=[X]_补+[-Y]_补$。

由 $[X]_补$ 求 $[-X]_补$ 的方法：$[X]_补$ 的各位取反（包括符号位），末尾加 1。

符号位也参与计算，如果计算结果超出符号位，则超出部分自然丢弃。<font color=skyblue>注意</font>：这不是溢出，所以可以对超出部分进行自然丢弃，参考例题 2。真正的溢出参考下面溢出及判定，真正的溢出会造成计算结果错误！！！

例题 1：

设二进制整数 $X=+1000100$，$Y=+1110$，求 X + Y、X - Y 的值。

![](图片\补码加减法例题 1.png)

例题 2：

![](图片\补码加减法例题 2.png)

**溢出及判定**

在确定了运算的字长和数据的表示方法后，数据的范围也就确定了。一旦运算结果超出所能表示的数据范围，就会发生溢出。<font color=skyblue>发生溢出时，运算结果肯定错误。只有当两个同符号的数相加（或者是相异符号数相减时），运算结果才有可能溢出。</font>

例题 1：

设正整数 $X=+1000001$，$Y=+1000011$，若用 8 位补码表示，则 $[X]_补=01000001$，$[Y]_补=01000011$，求$[X+Y]_补$。

 ![](图片\补码加减法溢出及判定例题 1.png)

例题 2：

![](图片\补码加减法溢出及判定例题 2.png)

常用的溢出检测机制主要有进位制判决法和双符号位判决法等如下几种方法。

双符号位判决法：采用两位表示符号，00 表示正号，11 表示负号，则溢出时两个符号位不一致就可以判定发生了溢出。若运算结果两符号位分别用 $S_2$ 和 $S_1$ 表示，则判别溢出的逻辑表示式位 $VF=S_2\oplus S_1$。

例题：

![](图片\双符号位判定法例题 1.png)

进位判决法：令 $C_{n-1}$ 表示最高数值位向最高位的进位，$C_n$ 表示符号位的进位，则 $C_{n-1}\oplus C_n=1$ 表示溢出。

根据运算结果的符号位和进位标志判别：该方法适用于两同号数求和或异号数求差时判别溢出。根据运算结果的符号位和进位标志，溢出的逻辑表达式为 $VF=SF\oplus CF$。1 为溢出。

根据运算前后的符号位进行判别。若用 $X_s$、$Y_s$、$Z_s$ 分别表示两个操作数及运算结果的符号位，当两个同符号数求和或异符号数求差时，就有可能发生溢出。溢出是否发生可根据运算前后的符号位进行判别，其逻辑表达式为 $VF=X_s\cdot Y_s\cdot \overline{Z_s}+\overline{X_s}\cdot \overline{Y_s}\cdot Zs$。1 为溢出。

也就是说双符号为判决法和进位判决法不需要判断式子是否符合两个同符号数求和或异符号数求差，而根据运算结果的符号位和进位标志判别和根据运算前后的符号位进行判别需要先对式子进行判别才可以。例如：$X=64$，$Y=-64$，求 $X+Y$。

###### 机器数的乘除运算

计算机中实现乘除法运算，有 3 中方式：

1. 纯软件方案，在只有加法器的抵挡计算机中，没有乘、除指令，乘除运算是用程序来完成。这种方案的硬件结构简单，但作乘除运算时速度很慢。
2. 在现有能够完成加减运算的算数逻辑单元 ALU 的基础上，通过增加少量的实现左、右移位的逻辑电路来实现乘除运算。这种方案增加硬件不多，而乘除运算的速度有了较大提高。
3. 设置专用的硬件阵列乘法器（或除法器），完成乘（除）法运算。该方案需要付出较高的硬件代价，可获得最快的执行速度。

###### 浮点运算

